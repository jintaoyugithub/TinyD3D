/*
* This sample mainly for demonstrate the followings:
* 1. Various resources uploading like vertex/index buffer, regular buffer, regular texture
* render targets and depth/stencil texture
* 2. Resources trasnsition between CPU and GPU with different types of heap
* 3. Resources binding via root signature inline descriptor, descriptor table, copy descriptors
* dynamic descriptor indexing in SM 6.6
* 4. Commited resources vs. Placed resource
* 5. CopyBufferRegion/CopyTextureRegion vs. Memcpy
* 6. Static vs. non-static sampler
* 7. Constant buffer with inline root parameters?
* 8. Texture with mip map
* 
* In addition, D3D Memory allocator integration
* 
* Note: Custom GPU memory management is optional!
*/

#pragma once

#include <d3dapp/application.hpp>
#include <D3D12MemAlloc.h>
#include <DirectXTex.h>
#include <filesystem>
#include <dxcapi.h>
#include <d3d12Backend/PipelineState.hpp>
#include <d3d12Backend/Queue.hpp>

using Microsoft::WRL::ComPtr;

/// TODO: move to resource.hpp
namespace tinyd3d {
using namespace DirectX;

struct Texture {
	TexMetadata metadata;
	ScratchImage rawImage;
	const wchar_t* filePath;

	// constructor
	Texture(const wchar_t* filename) {
		filePath = filename;
	}

	// Need to be manually call since we need to wait GPU finish 
	// using this resource
	void ReleaseImage() { rawImage.Release(); };
};
}

class ElemHelloResources : public tinyd3d::IAppElement {
public:
	ElemHelloResources() = default;
	~ElemHelloResources() = default;

public:
	void onAttach(tinyd3d::Application* app) override;
	void onDetach() override;
	void preRender() override;
	void onRender(ID3D12GraphicsCommandList* cmd) override;
	void onUIRender() override;
	void onResize() override;
	void postRender(ID3D12GraphicsCommandList* cmd) override;

	inline void setUsePlacedResource(bool usePlacedResource) { m_bUsePlacedResource = usePlacedResource; };
	inline void setUseDefaultHeap(bool useDefaultHeap) { m_bUseDefaultHeap = useDefaultHeap; };
	inline void setUseInlineDescriptor(bool useInlineDescriptor) { m_bUseInlineDescriptor = useInlineDescriptor; };

private:
	void createVertIdxBuffers();
	void createConstantBuffers();
	void createTextures(std::vector<const wchar_t*> filenames);
	///
	/// Create a read write texture and a read write buffer
	/// 
	void createUAVBuffers();

	void createGfxPso();
	void createCompPso();

private:
	bool m_bUsePlacedResource{ false };
	bool m_bUseDefaultHeap{ false };
	bool m_bUseInlineDescriptor{ true };

	/// Raw resources
	ComPtr<ID3D12Resource> m_vertBuffer;
	ComPtr<ID3D12Resource> m_indexBuffer;
	ComPtr<ID3D12Resource> m_lightsColorCB;
	ComPtr<ID3D12Resource> m_checkboardTex;
	std::vector<ComPtr<ID3D12Resource>> m_testeTexturesArray;
	// GPU generated texture and buffer
	ComPtr<ID3D12Resource> m_randomRWTex;
	ComPtr<ID3D12Resource> m_gpuParticleRW;

	/// Resource views
	D3D12_VERTEX_BUFFER_VIEW m_vertBufferView;
	D3D12_INDEX_BUFFER_VIEW m_indexBufferView;

	// TODO: Stream output buffer is specific for gpu generated data
	// such as extra vertices generated by geometry shader
	// some gpu particle system output
	// ComPtr<ID3D12Resource> m_streamOutputBuffer;

	/// Descriptor heaps
	uint32_t m_defaultHeapSize = 256;
	ComPtr<ID3D12DescriptorHeap> m_csuHeap; // cbv_srv_uav descriptor heap
	ComPtr<ID3D12DescriptorHeap> m_samplerHeap;
	ComPtr<ID3D12DescriptorHeap> m_csuHeapShaderVisible;
	ComPtr<ID3D12DescriptorHeap> m_samplerHeapShaderVisible;

	// size shoule be queried via device
	uint32_t m_csuHeapIncrementSize;
	uint32_t m_samplerHeapIncrementSize;

	// cpu staging heap handle
	D3D12_CPU_DESCRIPTOR_HANDLE m_csuBaseCpuHandle;
	D3D12_CPU_DESCRIPTOR_HANDLE m_samplerBaseCpuHandle;
	uint64_t m_csuCpuHandleOffset{ 0 };

	// shader visible heap handle
	D3D12_CPU_DESCRIPTOR_HANDLE m_csuSVBaseCpuHandle;
	D3D12_GPU_DESCRIPTOR_HANDLE m_csuSVBaseGpuHandle;
	uint64_t m_csuSVCpuHandleOffset{ 0 };
	uint64_t m_csuSVGpuHandleOffset{ 0 };
	D3D12_CPU_DESCRIPTOR_HANDLE m_samplerSVBaseCpuHandle;
	D3D12_GPU_DESCRIPTOR_HANDLE m_samplerSVBaseGpuHandle;

	/// For allocation with D3D12MemoryAllocator
	D3D12MA::Allocator* m_d3d12ma;

private:
	/// regular d3d members
	ComPtr<ID3D12Device> m_device;
	tinyd3d::Queue m_gfxQueue;
	tinyd3d::Queue m_mainCpyQueue;
	tinyd3d::Queue m_sedCpyQueue;

	// could be temp but since resources are created via several funcion
	// it's easier to make them globally accessbile
	ComPtr<ID3D12CommandAllocator> m_cpyAlloc;
	ComPtr<ID3D12GraphicsCommandList> m_cpyCmdList;

	/// Pipeline state object
	std::vector<tinyd3d::GfxShaderSet> m_gfxShaderSet;
	tinyd3d::GfxPipelineState m_gfxPso;
	tinyd3d::CompPipelineState m_compPso;
	
	/// Sync
	ComPtr<ID3D12Fence> m_cpyFence;
	uint64_t m_cpyFenceValue;
	HANDLE m_cpyFenceHandle;
};

/*
* Tips:
* 1. Texutes must be copied with CopyResource since different vendor has its own encode and decode system
* of the texture, we need the driver to help us do this
* 2. UpdateSubResource is a helper function which wrap the workflow from Map -> memcpy -> CopyBufferRegion/CopyTextureRegion -> Barrier
* simple Map and memcpy is cpu solid operation, CopyBuffer/TextureRegion is gpu cmd
* 3. Initialize the data before usage if the resources are created as placed resource
* 4. Since resource uploading is async, data in the upload heap cannot be modified until gpu consume the data which mean the end of 
* one frame, even you only use memcpy instead of CopyBuffer/TextureRegion
*/
